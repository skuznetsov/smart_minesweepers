<html>
<head>
    <title>Smart sweepers in JS</title>
    <style>
        #info {
            border: 1px dotted black;
            border-radius: 5px;
            display: block;
            position: fixed;
            padding: 15px;
            top: 30px;
            left: 10px;
            background-color:cornsilk;
        }
        #info > div {
            padding: 0;
        }

        #info > div > p {
            margin: 0;
            padding-bottom: 3px;
        }
    </style>
</head>
<body>
        <div id='generation'></div>
        <canvas id="battlefield" width="0" height="0"></canvas>
        <div id="info">
            <table>
                <tr>
                    <td>Hidden layers:</td>
                    <td><span id="hiddenLayers"></span></td>
                </tr>
                <tr>
                    <td>Neurons per hidden layer:</td>
                    <td><span id="neuronsPerHiddenLayer"></span></td>
                </tr>
                <tr>
                    <td>Population:</td>
                    <td><span id="popSize"></span></td>
                </tr>
                <tr>
                    <td>Mines:</td>
                    <td><span id="minesCount"></span></td>
                </tr>
                <tr>
                    <td>Mutation Rate:</td>
                    <td><span id="mutationRate"></span></td>
                </tr>
                <tr>
                    <td>Crossover Rate:</td>
                    <td><span id="crossoverRate"></span></td>
                </tr>
                <tr>
                    <td colspan=2><br/><b>HELP:</b></td>
                </tr>
                <tr>
                    <td><b>Keyboard<br/>Key</b></td>
                    <td><b>Action</b></td>
                </tr>
                <tr>
                    <td><b>S</b></td>
                    <td>Save custom state</td>
                </tr>
                <tr><td><b>L</b></td>
                    <td>Load custom state</td>
                </tr>
                <tr>
                    <td><b>R</b></td>
                    <td>Reset to initial state</td>
                </tr>
                <tr>
                    <td><b>P</b></td>
                    <td>Pause / Unpause</td>
                </tr>
                <tr>
                    <td><b>Up Arrow</b></td>
                    <td>Increase mines</td>
                </tr>
                <tr>
                    <td><b>Down Arrow</b></td>
                    <td>Decrease mines</td>
                </tr>
                <tr>
                    <td><b>Spacebar</b></td>
                    <td>Switch between fast mode (stats)<br/>and visual mode (movements)</td>
                </tr>
            </table>
        </div>
<script>
class Params {
    static get FastRender() {return true; }
    static get NumMines() { return 30; }
    static get NumSweepers() { return 50; }

    static get NumHidden() { return 3; }
    static get NeuronsPerHiddenLayer() { return 40; }
    static get NumTicks() { return 5000; }

    static get MaxTurnRate() { return 0.13; }
    static get MaxForwardSpeed() { return 1.75; }
    static get MaxBackwardSpeed() { return -1.25; }
    static get SweeperScale() { return 2; }
    static get MineScale() { return 3; }

    static get NumInputs() { return 6; }
    static get NumOutputs() { return 2; }
    static get ActivationResponse() { return 1; }
    static get Bias() { return 0; }

    static get MineSenseDistance() { return Math.pow(350, 2); }
    static get MineSenseRadius() { return Math.pow(15, 2); }

    static get CrossoverRate() { return 0.7; }
    static get MutationRate() { return 0.13; }
    static get MaxPerturbation() { return 0.37; }
    static get NumElite() { return (~~(Params.NumSweepers * 0.2) & 0xFE); }
    static get NumCopiesElite() { return 1; }

    static get HalfPi() { return Math.PI / 2; }
    static get TwoPi() { return Math.PI * 2; }
    static get WindowWidth() { return 1400; }
    static get WindowHeight() { return 640; }

}

function SPoint(x, y) {
    return {x, y};
}
const SweeperImageDots = [
    SPoint(-5, -5),
    SPoint(-5, 3),
    SPoint(-3, 3),
    SPoint(-3, 4),
    SPoint(-2, 5),
    SPoint(2, 5),
    SPoint(3, 4),
    SPoint(3, 3),
    SPoint(5, 3),
    SPoint(5, -5),
    SPoint(3, -5),
    SPoint(3, -3),
    SPoint(-3, -3),
    SPoint(-3, -5)

];

const MineImageDots = [
    SPoint(-1, -1),
    SPoint(-1, 1),
    SPoint(1, 1),
    SPoint(1, -1)
];

//-------------------------------------Clamp()-----------------------------------------
//
//	clamps the first argument between the second two
//
//-------------------------------------------------------------------------------------
function Clamp(arg, min, max)
{
	return arg < min ? min : arg > max ? max : arg;
}

//returns a random integer between x and y
function RandInt(x, y) {
    return ~~((Math.random() * y + x) % (y + 1));
}

//returns a random bool
function RandBool() {
	return !!RandInt(0,1);
}

//returns a random float in the range -1 < n < 1
function RandomClamped() {
    return Math.random() - Math.random();
}

/////////////////////////////////////////////////////////////////////
//
//	2D Vector class and methods
//
/////////////////////////////////////////////////////////////////////
class Vector2D {

    constructor(x, y) {
        if (x instanceof Vector2D) {
            this.x = x.x || 0.0;
            this.y = x.y || 0.0;
        } else {
            this.x = x || 0.0;
            this.y = y || 0.0;
        }
    }
	
	Add(rhs) {
		this.x += rhs.x;
		this.y += rhs.y;

		return this;
	}

    static Add(lhs, rhs) {
		return new Vector2D (lhs.x + rhs.x, lhs.y + rhs.y);
	}

	Substract(rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;

		return this;
	}

    static Substract(lhs, rhs) {
		return new Vector2D (lhs.x - rhs.x, lhs.y - rhs.y);
	}

	Multiply(rhs) {
		this.x *= rhs;
		this.y *= rhs;

		return this;
	}

    static Multiply(lhs, rhs) {
		return new Vector2D (lhs.x * rhs, lhs.y * rhs);
	}

  	Divide(rhs) {
		this.x /= rhs;
		this.y /= rhs;

		return this;
	}

    static Divide(lhs, rhs) {
		return new Vector2D (lhs.x / rhs, lhs.y / rhs);
	}

    get Length()
    {
	    return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    get SquaredLength()
    {
	    return this.x * this.x + this.y * this.y;
    }

    //------------------------------------------------------
    //	normalizes a 2D Vector
    //------------------------------------------------------
    Normalize()
    {
        let len = this.Length;

        if (len == 0) {
            this.x = 0;
            this.y = 0;
        } else {
            this.x = this.x / len;
            this.y = this.y / len;
        }

        return this;
    }

    static Normalize(v)
    {
        let result = new Vector2D(v);
        let len = result.Length;

        result.x = result.x / len;
        result.y = result.y / len;

        return result;
    }

    NormalizeBy(v)
    {
        this.x = this.x / v.x;
        this.y = this.y / v.y;

        return this;
    }

    Dot(v)
    {
        return this.x * v.x + this.y * v.y;
    }

    static Dot(v1, v2)
    {
        return v1.x * v2.x + v1.y * v2.y;
    }

    //------------------------ Sign --------------------------------
    //
    //  returns positive if v2 is clockwise of v1, minus if anticlockwise
    //-------------------------------------------------------------------
    Sign(v)
    {
        return (this.y * v.x > this.x * v.y) ? 1 : -1;
    }

    static Sign(v1, v2)
    {
        return (v1.y * v2.x > v1.x * v2.y) ? 1 : -1;
    }
}

class Minesweeper {

    constructor(world) {
        this.brain = new NeuralNet();
        this.rotation = Math.random() * Params.TwoPi;
        this.lTrack = 0.16;
        this.rTrack = 0.16;
        this.fitness = 0;
        this.closestMine = -1;
        this.lookAt = new Vector2D();
        //create a random start position
        this.position = new Vector2D( RandInt(0, Params.WindowWidth), RandInt(0, Params.WindowHeight));
        this.world = world;
    }

	get	Position() {
        return this.position;
    }

    IncrementFitness() {
        ++this.fitness;
    }

    get Fitness() {
        return this.fitness;
    }

    get Weights() {
        return this.brain.Weights;
    }

    set Weights(w) {
        this.brain.Weights = w;
    }

    get NumberOfWeights() {
        return this.brain.NumberOfWeights;
    }

    //-------------------------------------------Reset()--------------------
    //
    //	Resets the sweepers position, fitness and rotation
    //
    //----------------------------------------------------------------------
    Reset()
    {
        this.rotation = Math.random() * Params.TwoPi;
        this.fitness = 0;
        this.closestMine = -1;
        this.position = new Vector2D(RandInt(0, Params.WindowWidth), RandInt(0, Params.WindowHeight));
    }

    //-------------------------------Update()--------------------------------
    //
    //	First we take sensor readings and feed these into the sweepers brain.
    //
    //	The inputs are:
    //	
    //	A vector to the closest mine (x, y)
    //	The sweepers 'look at' vector (x, y)
    //
    //	We receive two outputs from the brain.. lTrack & rTrack.
    //	So given a force for each track we calculate the resultant rotation 
    //	and acceleration and apply to current velocity vector.
    //
    //-----------------------------------------------------------------------
    Update() {
        //this will store all the inputs for the NN
        let inputs = [];	

        //get vector to closest mine
        let deltaVector = this.GetClosestMine();

        //normalise it
        deltaVector.Normalize();

        // add current rotation and speed
        inputs.push((this.rotation || 0.001) / Params.TwoPi);

        let normalizedSpeed = this.speed > 0 ? this.speed / Params.MaxForwardSpeed : -this.speed / Params.MaxBackwardSpeed;
        inputs.push(normalizedSpeed || 0.001);

        //add in vector to closest mine
        inputs.push(deltaVector.x || 0.001);
        inputs.push(deltaVector.y || 0.001);

        // Add in sweepers look at vector
        let lookAtVector = new Vector2D(this.lookAt);
        lookAtVector.Normalize();
        inputs.push(lookAtVector.x || 0.001);
        inputs.push(lookAtVector.y || 0.001);

    
        //update the brain and get feedback
        let output = this.brain.Update(inputs);

        //make sure there were no errors in calculating the 
        //output
        if (output.length < Params.NumOutputs) 
        {
            return false;
        }

        //assign the outputs to the sweepers left & right tracks
        if (isNaN(output[0]) || isNaN(output[1])) {
            console.error('output is NaN');
        }
        this.lTrack = output[0];
        this.rTrack = output[1];

        //calculate steering forces
        let RotForce = this.lTrack - this.rTrack;

        //clamp rotation
        RotForce = Clamp(RotForce, -Params.MaxTurnRate, Params.MaxTurnRate);

        this.rotation += RotForce;
        this.rotation %= Params.TwoPi;
        
        this.speed = (this.lTrack + this.rTrack);
        this.speed = Clamp(this.speed, Params.MaxBackwardSpeed, Params.MaxForwardSpeed);

        //update Look At 
        this.lookAt.x = -Math.sin(this.rotation);
        this.lookAt.y = Math.cos(this.rotation);

        //update position
        this.position.Add(Vector2D.Multiply(this.lookAt, this.speed));

        //wrap around window limits
        if (this.position.x >= Params.WindowWidth) this.position.x = Params.WindowWidth - 3;
        if (this.position.x <= 0) this.position.x = 3;
        if (this.position.y >= Params.WindowHeight) this.position.y = Params.WindowHeight - 3;
        if (this.position.y <= 0) this.position.y = 3;

        return true;
    }


    //----------------------GetClosestObject()---------------------------------
    //
    //	returns the vector from the sweeper to the closest mine
    //
    //-----------------------------------------------------------------------
    GetClosestMine() {
        let closestSoFar = 9999999;
        let vClosestObject = new Vector2D();

        if (this.closestMine > -1 && this.closestMine < this.world.mines.length && Vector2D.Substract(this.position, this.world.mines[this.closestMine]).SquaredLength < Params.MineSenseDistance) {
            vClosestObject = Vector2D.Substract(this.position, this.world.mines[this.closestMine]);
        } else {
            //cycle through mines to find closest
            for (let i = 0; i < this.world.mines.length; i++)
            {
                let distanceToObject = Vector2D.Substract(this.world.mines[i], this.position).SquaredLength;
                if (distanceToObject < closestSoFar)
                {
                    closestSoFar = distanceToObject;
                    vClosestObject	= Vector2D.Substract(this.position, this.world.mines[i]);
                    this.closestMine = i;
                }
            }
        }

        return vClosestObject;
    }
    //----------------------------- CheckForMine -----------------------------
    //
    //  this function checks for collision with its closest mine (calculated
    //  earlier and stored in m_iClosestMine)
    //-----------------------------------------------------------------------
    CheckForMine() {
        if (this.closestMine < 0 && this.closestMine >= this.world.mines.length) {
            return -1;
        }
        let distToObject = Vector2D.Substract(this.position, this.world.mines[this.closestMine]);
            
        if (distToObject.SquaredLength < (Params.MineScale + Params.MineSenseRadius))
        {
                return this.closestMine;
        }

        return -1;
    }
}

class Controller {
    constructor() {
        this.Idle = true;
        this.numSweepers = Params.NumSweepers;
        this.GA = null;
        this.fastRender = Params.FastRender;
        this.ticks = 0;
        this.numMines = Params.NumMines;
        this.wndMain = null;
        this.generations = 0;
        this.xClient = Params.WindowWidth;
        this.yClient = Params.WindowHeight;
        this.sweepers = [];
        this.mines = [];
        this.avFitness = [];
        this.bestFitness = [];
        this.canvas = document.getElementById('battlefield');
        this.canvas.width = this.xClient;
        this.canvas.height = this.yClient;
        this.renderContext = this.canvas.getContext('2d');

        //let's create the mine sweepers
        for (let i=0; i<this.numSweepers; ++i)
        {
            this.sweepers.push(new Minesweeper(this));
        }

        //get the total number of weights used in the sweepers
        //NN so we can initialise the GA
        this.numWeightsInNN = this.sweepers[0].NumberOfWeights;

        //initialize the Genetic Algorithm class
        this.GA = new GenAlg(this.numSweepers,
                             Params.MutationRate,
                             Params.CrossoverRate,
                             this.numWeightsInNN);

        //Get the weights from the GA and insert into the sweepers brains
        this.thePopulation = this.GA.Chromos;

        for (let i = 0; i < this.numSweepers; i++) {
            this.sweepers[i].Weights = this.thePopulation[i].weights;
        }

        //initialize mines in random positions within the application window
        for (let i = 0; i < this.numMines; ++i) {
            this.createNewMine();
        }
    }

    displayAIInfo() {
        let brain = this.sweepers[0].brain;
        let ga = this.GA;
        this.DrawText("hiddenLayers", brain.numHiddenLayers)
        this.DrawText("neuronsPerHiddenLayer", brain.neuronsPerHiddenLayer);
        this.DrawText("popSize", ga.popSize);
        this.DrawText("minesCount", this.mines.length);
        this.DrawText("mutationRate", ga.mutationRate);
        this.DrawText("crossoverRate", ga.crossoverRate);
    }

    saveState(name, showAlert) {
        let copy = JSON.parse(JSON.stringify(this, (k, v) => k == 'world' ? undefined : v));
        for(let sweeper of copy.sweepers) {
            delete sweeper.brain.layers;
        }
        delete copy.GA.pop;
        delete copy.canvas;
        delete copy.renderContext;

        let json = JSON.stringify(copy);
        localStorage.setItem(name, json);
        if (showAlert) {
            alert("Custom state is saved");
        }
    }

    loadState(name, showAlert) {
        let json = localStorage.getItem(name);
        if (json) {
            let data = JSON.parse(json);
            let firstSweeper = data.sweepers[0];
            if (data.sweepers && data.sweepers.length > 0 && 
                firstSweeper.brain.neuronsPerHiddenLayer == Params.NeuronsPerHiddenLayer &&
                firstSweeper.brain.numHiddenLayers == Params.NumHidden) {
                Object.assign(this, data);
                this.Idle = true;
                this.GA = new GenAlg(0);
                Object.assign(this.GA, data.GA);
                let pop = [];
                for (let genome of data.thePopulation) {
                    pop.push(new Genome(genome.weights, genome.fitness));
                }
                
                this.thePopulation = pop;
                this.GA.pop = pop;
                this.GA.bestEverGenome = new Genome(data.GA.bestEverGenome.weights, data.GA.bestEverGenome.fitness);

                this.displayAIInfo(firstSweeper, this.GA);

                //let's restore the mine sweepers
                this.sweepers = [];
                for (let i=0; i<this.numSweepers; ++i)
                {
                    this.sweepers.push(new Minesweeper(this));
                    Object.assign(this.sweepers[i],data.sweepers[i]);
                    
                    let brain = new NeuralNet();
                    let oldBrain = data.sweepers[i].brain;
                    brain.numInputs	            = oldBrain.numInputs;
                    brain.numOutputs		    = oldBrain.numOutputs;
                    brain.numHiddenLayers	    = oldBrain.numHiddenLayers;
                    brain.neuronsPerHiddenLayer = oldBrain.neuronsPerHiddenLayer;
                    brain.layers = [];
                    this.sweepers[i].brain = brain;
                    this.sweepers[i].brain.CreateNet();

                    Object.assign(this.sweepers[i], {
                        lookAt: new Vector2D(data.sweepers[i].lookAt.x, data.sweepers[i].lookAt.y),
                        position: new Vector2D(data.sweepers[i].position.x, data.sweepers[i].position.y)
                    });
                }

                for (let i = 0; i < this.numSweepers; i++) {
                    this.sweepers[i].Weights = this.thePopulation[i].weights;
                }

                // Respore the mines positions from the loaded data
                this.mines = [];
                for (let i = 0; i < data.mines.length; ++i)
                {
                    this.mines.push(new Vector2D(data.mines[i].x,data.mines[i].y));
                }
            }
        }
        if (showAlert) {
            alert("Custom state is loaded");
        }
    }

    increaseMines() {
        this.createNewMine();
    }

    decreaseMines() {
        if (this.mines.length > 1) {
            this.mines.length--;
        }
    }

    createNewMine(idx) {
        let mineCoords = new Vector2D(RandInt(0, this.xClient), RandInt(0, this.yClient));
        if (idx !== undefined && idx >= 0 && idx < this.mines.length) {
            this.mines[idx] = mineCoords;
        } else {
            this.mines.push(mineCoords);
        }
    }

    CurrentBestFitness() {
        let bestFitness = 0;
        this.sweepers.forEach(sweeper => {bestFitness = Math.max(bestFitness, sweeper.fitness)});
        return bestFitness;
    }

    get PercentDone() {
        return ~~(this.ticks / Params.NumTicks * 100.0) + '%';
    }

    //-------------------------------------Update-----------------------------
    //
    //	This is the main workhorse. The entire simulation is controlled from here.
    //
    //	The comments should explain what is going on adequately.
    //-------------------------------------------------------------------------
    updateMineSweepers() {
        for (let i = 0; i < this.numSweepers; ++i)
        {
            // Update the NN and position of the minesweeper
            if (!this.sweepers[i].Update())
            {
                // Error in processing the neural net
                // TODO: Should we use Alert here?
                console.log("Wrong amount of NN inputs!");
                return false;
            }
                
            // Lets see if mine was found
            let grabHit = this.sweepers[i].CheckForMine();

            if (grabHit >= 0 && grabHit < this.mines.length)
            {
                // We have discovered a mine so increase fitness
                this.sweepers[i].IncrementFitness();

                // All other minesweepers are less lucky so we reset their targets
                for (let sweeper of this.sweepers) {
                    if(sweeper.closestMine == grabHit) {
                        sweeper.closestMine = -1;
                    }
                }

                // Mine was found so replace the mine with another at a random 
                // position
                this.createNewMine(grabHit);
            }

            // Uupdate the chromos fitness score
            this.thePopulation[i].fitness = this.sweepers[i].Fitness;
        }
    }

    UpdateGeneration() {
        // Update the stats to be used in our stat window
        this.avFitness.push(this.GA.AverageFitness());
        this.bestFitness.push(this.GA.BestFitness());

        // Increment the generation counter
        ++this.generations;

        //r Rset cycles
        this.ticks = 0;

        // Run the GA to create a new population
        this.thePopulation = this.GA.Epoch(this.thePopulation);
            
        // Insert the new (and hopefully) improved brains back into the sweepers
        // and reset their positions etc
        for (let i = 0; i < this.numSweepers; ++i) {
            if (!this.sweepers[i] || !this.thePopulation[i]) {
                continue;
            }
            this.sweepers[i].Weights = this.thePopulation[i].weights;
            this.sweepers[i].Reset();
        }
        controller.saveState("default");
        this.Idle = true;
    }

    Update()
    {
        // Run the sweepers through Params.NumTicks amount of cycles.
        // During this loop each sweepers NN is constantly updated with the appropriate
        // information from its surroundings.
        // The output from the NN is obtained and the sweeper is moved.
        // If it encounters a mine its fitness is updated appropriately,
        this.Idle = false;
        
        if (this.ticks++ < Params.NumTicks)
        {
            this.updateMineSweepers();
        }

        // Another generation has been completed.
        // Time to run the GA and update the sweepers with their new NNs
        else
        {
            this.UpdateGeneration();
        }

        return true;
    }

    //------------------------------------Render()--------------------------------------
    //
    //----------------------------------------------------------------------------------
    FastUpdate()
    {
        // In fast update we are simulating all ticks at once without any render
        // so it speeds up the simulation
        this.Idle = false;
        while (this.ticks++ < Params.NumTicks)
        {
            this.updateMineSweepers();
        }

        this.UpdateGeneration();
        this.PlotStats();
        this.Idle = true;

        return true;
    }

    //------------------------------------Render()--------------------------------------
    //
    //----------------------------------------------------------------------------------
    DrawText(id, text) {
        let el = document.getElementById(id);
        if (el){
            el.innerHTML = text;
        }
    }

    DisplayState(id, isShown) {
        let el = document.getElementById(id);
        if (el){
            el.style.display = isShown ? "block" : "none";
        }
    }

    DrawObject(type, obj, color, fitness) {
        let ctx = this.renderContext;
        let scale = type == 'mine' ? Params.MineScale : Params.SweeperScale;
        let pos = type == 'mine' ? obj : obj.position;
        let x = ~~pos.x,
            y = ~~pos.y;
        let tmpl = type == 'mine' ? MineImageDots : SweeperImageDots;
        ctx.save()
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.translate(x, y)
        ctx.scale(scale, scale);
        if(obj.rotation) {
            ctx.rotate(obj.rotation);
        }

        ctx.moveTo(tmpl[0].x,tmpl[0].y);
        for(let idx = 1; idx < tmpl.length; idx++) {
            let pt = tmpl[idx];
            ctx.lineTo(pt.x,pt.y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        if (type != "mine") {
            ctx.font = "20px Arial";
            ctx.fillColor = "green";
            ctx.fillText(fitness, x - 5, y - 10);
        }
    }

    Render() {
        let ctx = this.renderContext;
        ctx.clearRect(0,0, this.canvas.width, this.canvas.height);
        this.DrawText('generation', `Generation: ${this.generations}, Best fitness: ${this.CurrentBestFitness()}, Done: ${this.PercentDone}, Press <b>Spacebar</b> - to switch to fast mode (stats)`); //render the stats
        //do not render if running at accelerated speed
        if (!this.fastRender) {
            for (let mine of this.mines) { //render the mines
                this.DrawObject('mine', mine, 'green');
            }       
            this.sweepers.sort((lhs, rhs) => {
                return (rhs.fitness - lhs.fitness);
            });
            let color = 'red';
            for (let i = 0; i < this.numSweepers; i++) { //render the sweepers
                let sweeper = this.sweepers[i];
                if (i == Params.NumElite) {
                    color = 'blue';
                }
                this.DrawObject('sweeper', sweeper, color, sweeper.Fitness);
                if (i == 0) {
                    ctx.strokeStyle = 'purple';
                    ctx.beginPath();
                    ctx.arc(sweeper.position.x, sweeper.position.y, 15, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                if (sweeper.closestMine > -1) {
                    let mine = this.mines[sweeper.closestMine];
                    ctx.strokeStyle = 'green';
                    ctx.setLineDash([1,2]); // drawing a dotted line
                    ctx.beginPath();
                    ctx.moveTo(~~sweeper.position.x, ~~sweeper.position.y);
                    ctx.lineTo(~~mine.x, ~~mine.y);
                    ctx.stroke();
                    ctx.setLineDash([]); // resetting a style to the solid line.
                }
            }
        }
        this.Idle = true;
    }
    //--------------------------PlotStats-------------------------------------
    //
    //  Given a surface to draw on this function displays stats and a crude
    //  graph showing best and average fitness
    //------------------------------------------------------------------------
    PlotStats() {
        let ctx = this.renderContext;
        let totalBestFitness = Math.max(...this.bestFitness);
        totalBestFitness = isFinite(totalBestFitness) ? totalBestFitness : 0;
        this.DrawText('generation', `Generation: ${this.generations}, Best Ever Fitness: ${this.GA.bestEverFitness}, Total Average Fitness: ${this.GA.AverageFitness()}`);
        
        //render the graph
        let HSlice = Params.WindowWidth / (this.generations);
        let VSlice = Params.WindowHeight / (totalBestFitness + 1);

        //plot the graph for the best fitness
        let x = 0;
        ctx.clearRect(0,0, this.canvas.width, this.canvas.height);
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.moveTo(0, Params.WindowHeight);
        for (let idx = 0; idx < this.bestFitness.length; idx++)
        {
            ctx.lineTo( ~~x, ~~(Params.WindowHeight - VSlice * this.bestFitness[idx]));
            x += HSlice;
        }
        ctx.stroke();

        //plot the graph for the average fitness
        x = 0;
        ctx.beginPath();
        ctx.strokeStyle = 'blue';
        ctx.moveTo(0, Params.WindowHeight);
        for (let idx = 0; idx < this.avFitness.length; idx++)
        {
            ctx.lineTo(~~x, ~~(Params.WindowHeight - VSlice * this.avFitness[idx]));
            x += HSlice;
        }
        ctx.stroke();
    }
}

class Neuron {
    constructor(numInputs) {
        this.weights = [];
        this.numInputs = numInputs;  //we need an additional weight for the bias hence the +1
	    for (let i = 0; i < this.numInputs; ++i)
	    {
		    //set up the weights with an initial random value
		    this.weights.push(RandomClamped());
	    }
    }
}

class NeuronLayer {
    constructor (numNeurons, numInputsPerNeuron) {
        this.numNeurons = numNeurons;
        this.neurons = [];
        for (let i = 0; i < numNeurons; ++i) {
		    this.neurons.push(new Neuron(numInputsPerNeuron));
        }
    }
}

class NeuralNet {
    layers = [];

    constructor() 
    {
        this.numInputs	           = Params.NumInputs;
        this.numOutputs		       = Params.NumOutputs;
        this.numHiddenLayers	   = Params.NumHidden;
        this.neuronsPerHiddenLayer = Params.NeuronsPerHiddenLayer;

        this.CreateNet();
    }

    //------------------------------createNet()------------------------------
    //
    //	this method builds the ANN. The weights are all initially set to 
    //	random values -1 < w < 1
    //------------------------------------------------------------------------
    CreateNet()
    {
        //create the layers of the network
        if (this.numHiddenLayers > 0) {
            this.layers.push(new NeuronLayer(this.neuronsPerHiddenLayer, this.numInputs));
            for (let i = 0; i < this.numHiddenLayers - 1; ++i) {
                this.layers.push(new NeuronLayer(this.neuronsPerHiddenLayer, this.neuronsPerHiddenLayer));
            }
            //create output layer
            this.layers.push(new NeuronLayer(this.numOutputs, this.neuronsPerHiddenLayer));
        } else {
            //create output layer
            this.layers.push(new NeuronLayer(this.numOutputs, this.numInputs));
        }
    }

    get Weights() {
        let weights = [];
        for (let i = 0; i < this.numHiddenLayers + 1; ++i) {
            for (let j = 0; j < this.layers[i].numNeurons; ++j) {
                for (let k = 0; k < this.layers[i].neurons[j].numInputs; ++k) {
                    weights.push(this.layers[i].neurons[j].weights[k]);
                }
            }
        }
        return weights;
    }

    set Weights(weights) {
        let weightIndex = 0;

        if (!weights || weights.length < 39) { // Just to debug
            console.log('Something weird!');
        }

        for (let i = 0; i < this.numHiddenLayers + 1; ++i) {
            for (let j = 0; j < this.layers[i].numNeurons; ++j) {
                for (let k = 0; k < this.layers[i].neurons[j].numInputs; ++k) {
                    if (weightIndex < weights.length) {
                        this.layers[i].neurons[j].weights[k] = weights[weightIndex++];
                    }
                }
            }
        }
    }

    // TODO: Refactor this ugly code. It can be done in one line
    get NumberOfWeights() {
        let weights = 0;
        for (let i=0; i<this.numHiddenLayers + 1; ++i) {
            for (let j=0; j<this.layers[i].numNeurons; ++j) {
                for (let k=0; k<this.layers[i].neurons[j].numInputs; ++k) {
                    weights++;
                }
            }
        }
        return weights;
    }

    //-------------------------------Update-----------------------------------
    //
    //	given an input vector this function calculates the output vector
    //
    //------------------------------------------------------------------------
    Update(inputs) {
        //stores the resultant outputs from each layer
        let outputs = [];
        let cWeight = 0;
        if (inputs.length != this.numInputs) {
            return outputs;
        }
        
        //For each layer....
        for (let i=0; i<this.numHiddenLayers + 1; ++i) {		
            if ( i > 0 ) {
                inputs = outputs;
            }
            outputs = [];
            cWeight = 0;

            //for each neuron sum the (inputs * corresponding weights).Throw 
            //the total at our sigmoid function to get the output.
            for (let j = 0; j < this.layers[i].numNeurons; ++j) {
                let netinput = 0.0;
                let NumInputs = this.layers[i].neurons[j].numInputs;
                //for each weight
                for (let k=0; k<NumInputs; ++k) {
                    //sum the weights x inputs
                    netinput += this.layers[i].neurons[j].weights[k] * inputs[cWeight++];
                }
                //add in the bias
                netinput += Params.Bias;
                outputs.push(NeuralNet.Sigmoid(netinput, Params.ActivationResponse));
                cWeight = 0;
            }
        }
        return outputs;
    }

    static Sigmoid(netinput, response) {
	    return ( 1 / ( 1 + Math.exp(-netinput / response))) * 2.0 - 1.0;
    }
}

class Genome {
	weights = [];
	fitness = 0;

	constructor(w, f) {
        this.weights = w || [];
        this.fitness = f || 0;
    }

    static comparator(lhs, rhs) {
		return (lhs.fitness - rhs.fitness);
	}
};

class GenAlg {
    pop = []

    constructor ( popSize, mutRat, crossRat, numWeights) {
        this.popSize = popSize;
        this.mutationRate = mutRat;
        this.crossoverRate = crossRat;
        this.chromoLength = numWeights;
        this.totalFitness = 0;
        this.generation = 0;
        this.fittestGenome = 0;
        this.bestFitness = 0;
        this.bestEverFitness = 0;
        this.bestEverGenome = null;
        this.worstFitness = 99999999;
        this.averageFitness = 0;

        for (let i = 0; i < this.popSize; ++i) {
            this.pop.push(new Genome());
            for (let j = 0; j < this.chromoLength; ++j) {
                this.pop[i].weights.push(Clamp(RandomClamped(), -1.0, 1.0));
            }
        }
    }

    Mutate(chromo) {
        for (let i = 0; i < chromo.length; ++i) {
            //do we perturb this weight?
            if (Math.random() < this.mutationRate) {
                //add or subtract a small value to the weight
                let weight = chromo[i];
                weight += (RandomClamped() * Params.MaxPerturbation);
                chromo[i] = Clamp(weight, -1.0, 1.0);
            }
        }
    }

    GetChromoRoulette() {
        let slice = Math.random() * this.totalFitness;
        let theChosenOne;
        let fitnessSoFar = 0;
        
        for (let i = 0; i < this.popSize; ++i) {
            fitnessSoFar += this.pop[i].fitness;
            if (fitnessSoFar >= slice) {
                theChosenOne = this.pop[i];
                break;
            }
        }
        return theChosenOne;
    }

    Crossover(mum, dad) {
        let baby1 = [], baby2 = [];
        if ( (Math.random() > this.crossoverRate) || (mum == dad)) {
            baby1 = mum;
            baby2 = dad;

            return [baby1, baby2];
        }

        //determine a crossover point
        let cp = RandInt(0, this.chromoLength - 1);

        //create the offspring
        for (let i = 0; i < cp; ++i) {
            baby1.push(mum[i]);
            baby2.push(dad[i]);
        }
        for (let i = cp; i < mum.length; ++i) {
            baby1.push(dad[i]);
            baby2.push(mum[i]);
        }
        return [baby1, baby2];
    }

    //-----------------------------------Epoch()-----------------------------
    //
    //	takes a population of chromosones and runs the algorithm through one
    //	 cycle.
    //	Returns a new population of chromosones.
    //
    //-----------------------------------------------------------------------
    Epoch(oldPop) {
        //assign the given population to the classes population
        this.pop = oldPop;

        //reset the appropriate variables
        this.Reset();

        //sort the population (for scaling and elitism)
        this.pop.sort(Genome.comparator);

        //calculate best, worst, average and total fitness
        this.CalculateBestWorstAvTot();
    
        //create a temporary vector to store new chromosones
        let newPop = [];

        //Now to add a little elitism we shall add in some copies of the
        //fittest genomes. Make sure we add an EVEN number or the roulette
        //wheel sampling will crash
        if (!(Params.NumCopiesElite * Params.NumElite % 2)) {
            this.GrabNBest(Params.NumElite, Params.NumCopiesElite, newPop);
        }
        
        //now we enter the GA loop
        //repeat until a new population is generated
        while (newPop.length < this.popSize) {
            //grab two chromosones
            let mum = this.GetChromoRoulette();
            let dad = this.GetChromoRoulette();

            //create some offspring via crossover
            let [baby1, baby2] = this.Crossover(mum.weights, dad.weights);

            //now we mutate
            this.Mutate(baby1);
            this.Mutate(baby2);

            //now copy into newPop population
            newPop.push(new Genome(baby1, 0));
            newPop.push(new Genome(baby2, 0));
        }
        //finished so assign new pop back into m_vecPop
        this.pop = newPop;

        return this.pop;
    }


    //-------------------------GrabNBest----------------------------------
    //
    //	This works like an advanced form of elitism by inserting NumCopies
    //  copies of the NBest most fittest genomes into a population vector
    //--------------------------------------------------------------------
    GrabNBest(nBest, numCopies, pop) {
        //add the required amount of copies of the n most fittest 
        //to the supplied vector
        if (this.bestEverGenome) {
            pop.push(this.bestEverGenome);
            nBest--;
        }
        let pos = 0;
        while(pos < nBest) {
            for (let i = 0; i < numCopies; ++i) {
                pop.push(this.pop[(this.popSize - 1) - pos++]);
            }
        }
    }

    //-----------------------CalculateBestWorstAvTot-----------------------	
    //
    //	calculates the fittest and weakest genome and the average/total 
    //	fitness scores
    //---------------------------------------------------------------------
    CalculateBestWorstAvTot() {
        this.totalFitness = 0;
        let highestSoFar = 0;
        let lowestSoFar  = 9999999;
        
        for (let i = 0; i < this.popSize; ++i) {
            //update fittest if necessary
            if (this.pop[i].fitness > highestSoFar) {
                highestSoFar	   = this.pop[i].fitness;
                this.fittestGenome = i;
                this.bestFitness   = highestSoFar;
                if (this.bestFitness > this.bestEverFitness) {
                    this.bestEverFitness = this.bestFitness;
                    this.bestEverGenome = new Genome(JSON.parse(JSON.stringify(this.pop[i].weights)), 0);
                }
            }
            
            //update worst if necessary
            if (this.pop[i].fitness < lowestSoFar) {
                lowestSoFar        = this.pop[i].fitness;
                this.worstFitness  = lowestSoFar;
            }
            this.totalFitness	  += this.pop[i].fitness;   
        }
        this.averageFitness = this.totalFitness / this.popSize;
    }

    Reset() {
        this.totalFitness   = 0;
        this.bestFitness    = 0;
        this.worstFitness   = 9999999;
        this.averageFitness = 0;
    }

    get Chromos() {
        return this.pop;
    }
	AverageFitness() {
        return this.totalFitness / this.popSize;
    }
	BestFitness() {
        return this.bestFitness;
    }
}

let controller = new Controller();

let initialFlag = true;
function main() {
    if (initialFlag) {
        controller.loadState("default");
        initialFlag = false;
    }

    controller.displayAIInfo();
    if (controller.fastRender) {
        controller.FastUpdate();
    } else {
        if (controller.Idle) {
            controller.Update();
            controller.Render();
        }
    }
    raf = window.requestAnimationFrame(main);
}

document.addEventListener('keyup', key => {
    switch (key.code) {
        case "Space":
            // Spacebar is switching between fast (stats) and visual modes
            controller.fastRender = !controller.fastRender;
            controller.DisplayState('info', controller.fastRender);
            break;
        case "KeyS":
            // Here we can save the custom state that can be later loaded with L key
            // and it will override the default state that is saved after each generation

            controller.saveState("custom", true);
            break;
        case "KeyR":
            // If you hit the R key it will reset the default state to initial values

            if (!key.shiftKey && !key.altKey && !key.ctrlKey) {
                if (confirm("Are you sure you want to reset the state?")) {
                    controller = new Controller();
                    initialFlag = false;
                }
            }
            break;
        case "KeyP":
            // Calculations can be paused if needed 

            controller.Idle = !controller.Idle;
            break;
        case "KeyL":
            // Loading custom state that was initially saved if you hit the S key
            
            controller.loadState("custom", true);
            break;
        case "ArrowUp":
            controller.increaseMines();
            break;
        case "ArrowDown":
            controller.decreaseMines();
            break;
        default:
            break;
    }
});

main();


</script>
</body>
</html>